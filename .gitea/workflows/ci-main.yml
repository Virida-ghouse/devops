name: VIRIDA CI - Main Pipeline

# DÃ©clenchement sur chaque branche du repo VIRIDA
on:
  push:
  pull_request:
  workflow_dispatch:

env:
  NODE_VERSION: '18'
  # Ensure frontend doesn't trigger expensive postinstall builds during CI installs
  NPM_CONFIG_IGNORE_SCRIPTS: 'true'

jobs:
  # ========================================
  # VALIDATION
  # ========================================
  validate:
    runs-on: virida-host
    name: Validate Code
    
    steps:
    - name: CI dÃ©clenchÃ©e
      run: |
        echo "ðŸš€ CI lancÃ©e sur branche: ${{ github.ref_name }}"
        echo "ðŸ“ Commit: ${{ github.sha }}"
        echo "ðŸ‘¤ Auteur: ${{ github.actor }}"
    
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITEA }}
        submodules: false

    - name: Checkout virida_api
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_api
        ref: main
        path: virida_api
        token: ${{ secrets.GITEA }}

    - name: Checkout virida_app
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_app
        ref: master
        path: virida_app
        token: ${{ secrets.GITEA }}
      
    - name: Validate YAML files
      run: |
        echo "Validating YAML configuration files..."
        ERROR_COUNT=0
        # Valider seulement les workflows (pas actions.yml qui a un format diffÃ©rent)
        for file in .gitea/workflows/*.yml; do
          if [ -f "$file" ]; then
            echo "Validating $file"
            # VÃ©rifier que le fichier contient "name:" quelque part dans les premiÃ¨res lignes
            if head -5 "$file" | grep -q "name:"; then
              echo "  [OK] $file is valid"
            else
              echo "  [ERROR] Invalid workflow: $file (missing 'name:' field)"
              ERROR_COUNT=$((ERROR_COUNT + 1))
            fi
          fi
        done
        if [ $ERROR_COUNT -gt 0 ]; then
          echo "[ERROR] Found $ERROR_COUNT invalid workflow file(s)"
          exit 1
        fi
        echo "[OK] All workflow YAML files are valid"
        
    - name: Validate JSON files
      run: |
        echo "Validating JSON configuration files..."
        find . -maxdepth 1 -name "*.json" -type f | while read file; do
          echo "Validating $file"
          python3 -m json.tool "$file" > /dev/null || { echo "[ERROR] Invalid JSON: $file"; exit 1; }
        done
        echo "[OK] All JSON files are valid"

  # ========================================
  # TESTS FRONTEND (virida_app)
  # ========================================
  test-frontend:
    runs-on: virida-host
    name: Test Frontend (virida_app)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITEA }}
        submodules: false

    - name: Checkout virida_api
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_api
        ref: main
        path: virida_api
        token: ${{ secrets.GITEA }}

    - name: Checkout virida_app
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_app
        ref: master
        path: virida_app
        token: ${{ secrets.GITEA }}
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: npm
        cache-dependency-path: virida_app/package-lock.json

    - name: Check virida_app exists
      id: check_frontend
      run: |
        if [ -d "virida_app" ] && [ -f "virida_app/package.json" ]; then
          echo "exists=true" >> "$GITHUB_OUTPUT"
        else
          echo "exists=false" >> "$GITHUB_OUTPUT"
          echo "[INFO] virida_app not present in this repo checkout; skipping frontend job."
        fi
        
    - name: Install dependencies
      if: steps.check_frontend.outputs.exists == 'true'
      working-directory: virida_app
      run: |
        npm ci --ignore-scripts || npm install --ignore-scripts
      
    - name: Lint code
      if: steps.check_frontend.outputs.exists == 'true'
      working-directory: virida_app
      run: npm run lint || true
      
    - name: Run tests
      if: steps.check_frontend.outputs.exists == 'true'
      working-directory: virida_app
      run: npm test
      
    - name: Build
      if: steps.check_frontend.outputs.exists == 'true'
      working-directory: virida_app
      timeout-minutes: 10
      env:
        NODE_OPTIONS: --max-old-space-size=1536 --no-warnings
      run: npm run build:simple

  # ========================================
  # TESTS BACKEND (virida_api)
  # ========================================
  test-backend:
    runs-on: virida-host
    name: Test Backend (virida_api)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITEA }}
        submodules: false

    - name: Checkout virida_api
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_api
        ref: main
        path: virida_api
        token: ${{ secrets.GITEA }}

    - name: Checkout virida_app
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_app
        ref: master
        path: virida_app
        token: ${{ secrets.GITEA }}
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: npm
        cache-dependency-path: virida_api/package-lock.json

    - name: Check virida_api exists
      id: check_backend
      run: |
        if [ -d "virida_api" ] && [ -f "virida_api/package.json" ]; then
          echo "exists=true" >> "$GITHUB_OUTPUT"
        else
          echo "exists=false" >> "$GITHUB_OUTPUT"
          echo "[INFO] virida_api not present in this repo checkout; skipping backend job."
        fi
        
    - name: Install dependencies
      if: steps.check_backend.outputs.exists == 'true'
      working-directory: virida_api
      run: |
        npm ci
        export DATABASE_URL="postgresql://user:pass@localhost:5432/virida?schema=public"
        npx prisma generate
      
    - name: Lint code
      if: steps.check_backend.outputs.exists == 'true'
      working-directory: virida_api
      run: npm run lint || echo "[WARN] Linting completed with warnings"
      
    - name: Run tests
      if: steps.check_backend.outputs.exists == 'true'
      working-directory: virida_api
      env:
        NODE_OPTIONS: --no-warnings
      run: npm test -- --ci --runInBand
      
    - name: Build test
      if: steps.check_backend.outputs.exists == 'true'
      working-directory: virida_api
      run: npm run build || echo "[INFO] Build test completed"

  # ========================================
  # SECURITY SCAN
  # ========================================
  security:
    runs-on: virida-host
    name: Security Scan
    needs: [validate]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITEA }}
        submodules: false

    - name: Checkout virida_api
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_api
        ref: main
        path: virida_api
        token: ${{ secrets.GITEA }}

    - name: Checkout virida_app
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_app
        ref: master
        path: virida_app
        token: ${{ secrets.GITEA }}
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: npm
        cache-dependency-path: |
          virida_app/package-lock.json
          virida_api/package-lock.json
        
    - name: Scan Frontend dependencies
      if: ${{ hashFiles('virida_app/package.json') != '' }}
      working-directory: virida_app
      run: |
        npm audit --audit-level=moderate || echo "[WARN] Security vulnerabilities found in virida_app"
        
    - name: Scan Backend dependencies
      if: ${{ hashFiles('virida_api/package.json') != '' }}
      working-directory: virida_api
      run: |
        npm audit --audit-level=moderate || echo "[WARN] Security vulnerabilities found in virida_api"

  # ========================================
  # BUILD
  # ========================================
  build:
    runs-on: virida-host
    name: Build All
    needs: [test-frontend, test-backend]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITEA }}
        submodules: false

    - name: Checkout virida_api
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_api
        ref: main
        path: virida_api
        token: ${{ secrets.GITEA }}

    - name: Checkout virida_app
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_app
        ref: master
        path: virida_app
        token: ${{ secrets.GITEA }}
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: npm
        cache-dependency-path: |
          virida_app/package-lock.json
          virida_api/package-lock.json
        
    - name: Build Frontend
      if: ${{ hashFiles('virida_app/package.json') != '' }}
      working-directory: virida_app
      run: |
        npm ci --ignore-scripts || npm install --ignore-scripts
        NODE_OPTIONS="--max-old-space-size=1536 --no-warnings" npm run build:simple
        echo "[OK] Frontend build successful"
        
    - name: Build Backend
      if: ${{ hashFiles('virida_api/package.json') != '' }}
      working-directory: virida_api
      run: |
        npm ci
        npm run build || echo "[INFO] Backend build completed"
        echo "[OK] Backend build successful"

  # ========================================
  # SONARQUBE ANALYSIS
  # ========================================
  sonarqube:
    runs-on: virida-host
    name: SonarQube Analysis
    needs: [test-frontend, test-backend]
    # Ne pas "skipper" Sonar : Ã©chouer clairement si secrets manquants
    if: ${{ always() }}

    steps:
    - name: VÃ©rifier les secrets Sonar
      run: |
        if [ -z "${{ secrets.SONAR_TOKEN }}" ] || [ -z "${{ secrets.SONAR_HOST_URL }}" ]; then
          echo "::error::Secrets Sonar manquants: SONAR_TOKEN et/ou SONAR_HOST_URL"
          exit 1
        fi

    - name: Checkout code (with submodules)
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITEA }}
        submodules: false

    - name: Checkout virida_api
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_api
        ref: main
        path: virida_api
        token: ${{ secrets.GITEA }}

    - name: Checkout virida_app
      uses: actions/checkout@v3
      with:
        repository: Virida/virida_app
        ref: master
        path: virida_app
        token: ${{ secrets.GITEA }}

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: npm
        cache-dependency-path: |
          virida_app/package-lock.json
          virida_api/package-lock.json

    - name: Install + test backend (generate coverage)
      if: ${{ hashFiles('virida_api/package.json') != '' }}
      working-directory: virida_api
      env:
        NODE_OPTIONS: --no-warnings
      run: |
        npm ci
        export DATABASE_URL="postgresql://user:pass@localhost:5432/virida?schema=public"
        npx prisma generate
        npm test -- --ci --runInBand --coverage

    - name: Install + test frontend
      if: ${{ hashFiles('virida_app/package.json') != '' }}
      working-directory: virida_app
      timeout-minutes: 15
      env:
        NODE_OPTIONS: --no-warnings
        CI: "true"
      run: |
        npm ci --ignore-scripts || npm install --ignore-scripts
        npm test

    # NOTE: The official SonarQube actions use Docker. Our runner doesn't provide
    # a Docker daemon, so we run SonarScanner CLI directly (no Docker).
    - name: Install SonarScanner CLI (no Docker)
      env:
        SONAR_SCANNER_VERSION: "8.0.1.6346"
        SONAR_SCANNER_DIR: "/tmp/sonar-scanner"
      run: |
        set -euo pipefail
        curl -sSLo /tmp/sonar-scanner.zip "https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-${SONAR_SCANNER_VERSION}-linux-x64.zip"
        rm -rf "${SONAR_SCANNER_DIR}" "/tmp/sonar-scanner-${SONAR_SCANNER_VERSION}-linux-x64"
        unzip -q /tmp/sonar-scanner.zip -d /tmp
        mv "/tmp/sonar-scanner-${SONAR_SCANNER_VERSION}-linux-x64" "${SONAR_SCANNER_DIR}"
        "${SONAR_SCANNER_DIR}/bin/sonar-scanner" --version

    - name: SonarQube scan + quality gate (virida_api)
      if: ${{ hashFiles('virida_api/package.json') != '' }}
      working-directory: virida_api
      timeout-minutes: 10
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      run: |
        set -euo pipefail

        "${SONAR_SCANNER_DIR}/bin/sonar-scanner" \
          -Dsonar.host.url="${SONAR_HOST_URL}" \
          -Dsonar.token="${SONAR_TOKEN}" \
          -Dsonar.projectKey=virida_api \
          -Dsonar.projectName=virida_api \
          -Dsonar.sources=src \
          -Dsonar.tests=tests \
          -Dsonar.test.inclusions=tests/**/* \
          -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info \
          -Dsonar.sourceEncoding=UTF-8

        REPORT=".scannerwork/report-task.txt"
        if [ ! -f "$REPORT" ]; then
          echo "::error::Sonar report-task.txt introuvable ($REPORT)"
          exit 1
        fi

        ceTaskUrl="$(grep -E '^ceTaskUrl=' "$REPORT" | cut -d= -f2-)"
        if [ -z "${ceTaskUrl:-}" ]; then
          echo "::error::ceTaskUrl introuvable dans $REPORT"
          exit 1
        fi

        echo "[INFO] Waiting for SonarQube CE task..."
        analysisId=""
        for i in $(seq 1 60); do
          json="$(curl -sS -u "${SONAR_TOKEN}:" "$ceTaskUrl")"
          status="$(python3 -c 'import json,sys; print(json.loads(sys.stdin.read())["task"]["status"])' <<<"$json")"
          analysisId="$(python3 -c 'import json,sys; print(json.loads(sys.stdin.read())["task"].get("analysisId",""))' <<<"$json")"
          if [ "$status" = "SUCCESS" ] && [ -n "$analysisId" ]; then
            break
          fi
          if [ "$status" = "FAILED" ] || [ "$status" = "CANCELED" ]; then
            echo "::error::SonarQube compute engine status=$status"
            echo "$json"
            exit 1
          fi
          sleep 2
        done

        if [ -z "$analysisId" ]; then
          echo "::error::Timeout SonarQube: analysisId non reÃ§u"
          exit 1
        fi

        qg="$(curl -sS -u "${SONAR_TOKEN}:" "${SONAR_HOST_URL}/api/qualitygates/project_status?analysisId=${analysisId}")"
        qgStatus="$(python3 -c 'import json,sys; print(json.loads(sys.stdin.read())["projectStatus"]["status"])' <<<"$qg")"
        echo "[INFO] Quality Gate: $qgStatus"
        if [ "$qgStatus" != "OK" ]; then
          echo "::error::Quality Gate FAILED: $qgStatus"
          echo "$qg"
          exit 1
        fi

    - name: SonarQube scan + quality gate (virida_app)
      if: ${{ hashFiles('virida_app/package.json') != '' }}
      working-directory: virida_app
      timeout-minutes: 10
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      run: |
        set -euo pipefail

        "${SONAR_SCANNER_DIR}/bin/sonar-scanner" \
          -Dsonar.host.url="${SONAR_HOST_URL}" \
          -Dsonar.token="${SONAR_TOKEN}" \
          -Dsonar.projectKey=virida_app \
          -Dsonar.projectName=virida_app \
          -Dsonar.sources=src \
          -Dsonar.tests=src \
          -Dsonar.test.inclusions=src/**/*.test.ts,src/**/*.test.tsx,src/**/*.integration.test.tsx \
          -Dsonar.exclusions=dist/**,public/**,node_modules/**,**/*.d.ts \
          -Dsonar.sourceEncoding=UTF-8

        REPORT=".scannerwork/report-task.txt"
        if [ ! -f "$REPORT" ]; then
          echo "::error::Sonar report-task.txt introuvable ($REPORT)"
          exit 1
        fi

        ceTaskUrl="$(grep -E '^ceTaskUrl=' "$REPORT" | cut -d= -f2-)"
        if [ -z "${ceTaskUrl:-}" ]; then
          echo "::error::ceTaskUrl introuvable dans $REPORT"
          exit 1
        fi

        echo "[INFO] Waiting for SonarQube CE task..."
        analysisId=""
        for i in $(seq 1 60); do
          json="$(curl -sS -u "${SONAR_TOKEN}:" "$ceTaskUrl")"
          status="$(python3 -c 'import json,sys; print(json.loads(sys.stdin.read())["task"]["status"])' <<<"$json")"
          analysisId="$(python3 -c 'import json,sys; print(json.loads(sys.stdin.read())["task"].get("analysisId",""))' <<<"$json")"
          if [ "$status" = "SUCCESS" ] && [ -n "$analysisId" ]; then
            break
          fi
          if [ "$status" = "FAILED" ] || [ "$status" = "CANCELED" ]; then
            echo "::error::SonarQube compute engine status=$status"
            echo "$json"
            exit 1
          fi
          sleep 2
        done

        if [ -z "$analysisId" ]; then
          echo "::error::Timeout SonarQube: analysisId non reÃ§u"
          exit 1
        fi

        qg="$(curl -sS -u "${SONAR_TOKEN}:" "${SONAR_HOST_URL}/api/qualitygates/project_status?analysisId=${analysisId}")"
        qgStatus="$(python3 -c 'import json,sys; print(json.loads(sys.stdin.read())["projectStatus"]["status"])' <<<"$qg")"
        echo "[INFO] Quality Gate: $qgStatus"
        if [ "$qgStatus" != "OK" ]; then
          echo "::error::Quality Gate FAILED: $qgStatus"
          echo "$qg"
          exit 1
        fi

  # ========================================
  # SUMMARY
  # ========================================
  ci-summary:
    runs-on: virida-host
    name: CI Summary
    needs: [validate, test-frontend, test-backend, security, build, sonarqube]
    if: always()
    
    steps:
    - name: CI Summary
      run: |
        echo "VIRIDA CI Pipeline Summary"
        echo "=============================="
        echo "Date: $(date)"
        echo "Branch: ${{ gitea.ref_name || 'devops_crk' }}"
        echo "Commit: ${{ gitea.sha }}"
        echo ""
        echo "Jobs Status:"
        echo "  [OK] Validate: ${{ needs.validate.result }}"
        echo "  [OK] Test Frontend: ${{ needs.test-frontend.result }}"
        echo "  [OK] Test Backend: ${{ needs.test-backend.result }}"
        echo "  [OK] Security: ${{ needs.security.result }}"
        echo "  [OK] Build: ${{ needs.build.result }}"
        echo "  [OK] SonarQube: ${{ needs.sonarqube.result }}"
        echo ""
        # Accept SonarQube being skipped when not configured yet
        SONAR_OK="false"
        if [[ "${{ needs.sonarqube.result }}" == "success" || "${{ needs.sonarqube.result }}" == "skipped" ]]; then
          SONAR_OK="true"
        fi

        if [[ "${{ needs.validate.result }}" == "success" && \
              "${{ needs.test-frontend.result }}" == "success" && \
              "${{ needs.test-backend.result }}" == "success" && \
              "${{ needs.build.result }}" == "success" && \
              "${SONAR_OK}" == "true" ]]; then
          echo "[SUCCESS] All CI checks passed!"
          exit 0
        else
          echo "[WARN] Some CI checks had issues"
          exit 0
        fi

